package net.minestom.codegen.damage;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.squareup.javapoet.*;
import net.minestom.codegen.MinestomCodeGenerator;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

// Wagasa
public class DamageTypeGenerator extends MinestomCodeGenerator {
    private static final Logger LOGGER = LoggerFactory.getLogger(DamageTypeGenerator.class);
    private final InputStream damageTypesFile;
    private final File outputFolder;

    public DamageTypeGenerator(InputStream damageTypesFile, File outputFolder) {
        this.damageTypesFile = damageTypesFile;
        this.outputFolder = outputFolder;
    }

    @Override
    public void generate() {
        if (damageTypesFile == null) {
            LOGGER.error("Failed to find damage_types.json.");
            LOGGER.error("Stopped code generation for damage types.");
            return;
        }
        if (!outputFolder.exists() && !outputFolder.mkdirs()) {
            LOGGER.error("Output folder for code generation does not exist and could not be created.");
            return;
        }

        final var damageTypes = GSON.fromJson(new InputStreamReader(damageTypesFile), JsonObject.class);
        final var damageTypesCN = ClassName.get("net.minestom.server.damage", "VanillaDamageTypes");
        final var classBuilder = TypeSpec.classBuilder(damageTypesCN)
                .addJavadoc("AUTOGENERATED by " + getClass().getSimpleName())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unused").build())
                .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

        final var fields = new ArrayList<String>();
        final var namespaceIdCN = ClassName.get("net.minestom.server.utils", "NamespaceID");
        final var damageTypeCN = ClassName.get("dev.uten2c.wagasa.damage", "VanillaDamageType");
        final var damageScalingCN = ClassName.get("dev.uten2c.wagasa.damage", "DamageScaling");
        final var damageEffectsCN = ClassName.get("dev.uten2c.wagasa.damage", "DamageEffects");
        final var deathMessageTypeCN = ClassName.get("dev.uten2c.wagasa.damage", "DeathMessageType");
        for (Map.Entry<String, JsonElement> entry : damageTypes.entrySet()) {
            final var fieldName = entry.getKey().split(":")[1].toUpperCase();
            fields.add(fieldName);
            final var jsonObject = entry.getValue().getAsJsonObject();
            var codeBlock = CodeBlock.builder()
                    .add("$T.builder()\n", damageTypeCN)
                    .add(CodeBlock.builder().indent().indent().build())
                    .add(".name($T.from($S))\n", namespaceIdCN, entry.getKey());

            if (jsonObject.has("message_id")) {
                codeBlock.add(".messageId($S)\n", jsonObject.get("message_id").getAsString());
            }

            if (jsonObject.has("scaling")) {
                codeBlock.add(".scaling($T.$L)\n", damageScalingCN, jsonObject.get("scaling").getAsString().toUpperCase());
            }

            if (jsonObject.has("exhaustion")) {
                codeBlock.add(".exhaustion($Lf)\n", jsonObject.get("exhaustion").getAsFloat());
            }

            if (jsonObject.has("effects")) {
                codeBlock.add(".effects($T.$L)\n", damageEffectsCN, jsonObject.get("effects").getAsString().toUpperCase());
            }

            if (jsonObject.has("death_message_type")) {
                codeBlock.add(".deathMessageType($T.$L)\n", deathMessageTypeCN, jsonObject.get("death_message_type").getAsString().toUpperCase());
            }

            codeBlock.add(".build()")
                    .add(CodeBlock.builder().unindent().unindent().build());
            final var field = FieldSpec.builder(damageTypeCN, fieldName, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .addAnnotation(NotNull.class)
                    .initializer(codeBlock.build())
                    .build();
            classBuilder.addField(field);
        }


        final var listCN = ClassName.get("java.util", "List");
        final var arraysCN = ClassName.get("java.util", "Arrays");
        final var valuesInitializer = CodeBlock.builder();
        valuesInitializer.add("$T.asList(\n", arraysCN);
        valuesInitializer.indent().indent();
        for (int i = 0; i < fields.size(); i++) {
            if (i != 0) {
                valuesInitializer.add(",\n");
            }
            valuesInitializer.add("$L", fields.get(i));
        }
        valuesInitializer.unindent().unindent();
        valuesInitializer.add("\n)");
        final var valuesField = FieldSpec.builder(ParameterizedTypeName.get(listCN, damageTypeCN), "VALUES", Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer(valuesInitializer.build())
                .build();
        classBuilder.addField(valuesField);

        final var file = JavaFile.builder("dev.uten2c.wagasa.damage", classBuilder.build())
                .indent("    ")
                .skipJavaLangImports(true)
                .build();
        writeFiles(List.of(file), outputFolder);
    }
}
